#!/bin/bash
# ============================================================================
# OTP Key Programming Script for DiveChecker (RP2350)
# ============================================================================
#
# âš ï¸  CRITICAL WARNING: OTP PROGRAMMING IS PERMANENT AND IRREVERSIBLE!
# âš ï¸  Once written, keys CANNOT be changed!
# âš ï¸  Test thoroughly before running this script!
#
# Prerequisites:
# 1. picotool installed and in PATH (version 2.0+)
# 2. Keys generated by generate_keys.sh
# 3. Device in BOOTSEL mode
#
# Usage:
#   ./program_otp_keys.sh              # Real OTP programming (PERMANENT!)
#   ./program_otp_keys.sh --dry-run    # Test run (no actual writes)
#
# ============================================================================

set -e

# Colors for output (must be defined early for --dry-run message)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Parse command line arguments
DRY_RUN=0
if [ "$1" == "--dry-run" ]; then
    DRY_RUN=1
    echo -e "${YELLOW}ğŸ” DRY-RUN MODE: No OTP writes will be performed${NC}"
    echo ""
fi

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
KEYS_DIR="$SCRIPT_DIR/keys"
HEADER_FILE="$KEYS_DIR/ecdsa_private_keys.h"

# OTP row addresses (must match otp_keys.h)
OTP_PRIVATE_KEY_ROW=0x700
OTP_PUBLIC_KEY_ROW=0x710
OTP_KEY_FLAG_ROW=0x740
OTP_KEY_MAGIC=0xDC01

echo ""
echo "=============================================="
echo "   DiveChecker OTP Key Programming Tool"
echo "=============================================="
echo ""

# Verify we're in the right directory (security: prevent running from wrong location)
if [[ ! "$SCRIPT_DIR" == *"0_Pico2-Firmware/Divechecker"* ]]; then
    echo -e "${RED}âŒ ERROR: Script must be run from Divechecker firmware directory${NC}"
    exit 1
fi

# Additional security: verify HEADER_FILE is within SCRIPT_DIR
HEADER_REALPATH=$(realpath "$HEADER_FILE" 2>/dev/null || echo "")
SCRIPT_REALPATH=$(realpath "$SCRIPT_DIR" 2>/dev/null || echo "")
if [[ ! "$HEADER_REALPATH" == "$SCRIPT_REALPATH"* ]]; then
    echo -e "${RED}âŒ ERROR: Key file must be within script directory${NC}"
    echo "   Script dir: $SCRIPT_REALPATH"
    echo "   Key file: $HEADER_REALPATH"
    exit 1
fi

# Check if keys exist
if [ ! -f "$HEADER_FILE" ]; then
    echo -e "${RED}âŒ ERROR: Keys not found!${NC}"
    echo "   Expected: $HEADER_FILE"
    echo "   Run generate_keys.sh first."
    exit 1
fi

# Check picotool - also search in common locations
PICOTOOL_CMD=""
if command -v picotool &> /dev/null; then
    PICOTOOL_CMD="picotool"
elif [ -f "$HOME/.pico-sdk/picotool/2.2.0-a4/picotool/picotool" ]; then
    PICOTOOL_CMD="$HOME/.pico-sdk/picotool/2.2.0-a4/picotool/picotool"
elif [ -f "$HOME/.pico-sdk/picotool/2.2.0/picotool/picotool" ]; then
    PICOTOOL_CMD="$HOME/.pico-sdk/picotool/2.2.0/picotool/picotool"
else
    # Try to find picotool in ~/.pico-sdk
    PICOTOOL_FOUND=$(find "$HOME/.pico-sdk" -name "picotool" -type f -executable 2>/dev/null | head -1)
    if [ -n "$PICOTOOL_FOUND" ]; then
        PICOTOOL_CMD="$PICOTOOL_FOUND"
    fi
fi

if [ -z "$PICOTOOL_CMD" ]; then
    echo -e "${RED}âŒ ERROR: picotool not found!${NC}"
    echo "   Searched in PATH and ~/.pico-sdk/"
    echo "   Install picotool or check your pico-sdk installation."
    exit 1
fi

echo "   Using picotool: $PICOTOOL_CMD"

# Check picotool version (need 2.0+ for OTP support)
PICOTOOL_VER=$($PICOTOOL_CMD version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+' | head -1 || echo "0.0")
echo "   picotool version: $PICOTOOL_VER"

# Verify picotool OTP command syntax
echo ""
echo "ğŸ” Verifying picotool OTP command syntax..."
if ! $PICOTOOL_CMD otp --help 2>&1 | grep -q "set"; then
    echo -e "${RED}âŒ ERROR: picotool 'otp set' command not available!${NC}"
    echo "   Your picotool may need to be updated or rebuilt."
    echo "   Required: picotool 2.0+ with OTP support"
    exit 1
fi
echo -e "${GREEN}âœ“ picotool OTP commands available${NC}"

# Extract keys from header file
echo "ğŸ“– Reading keys from $HEADER_FILE..."

# More robust extraction: find the specific arrays by name
# Extract private key: find "ECDSA_PRIVATE_KEY[32]" section and get 32 hex bytes
PRIV_SECTION=$(sed -n '/ECDSA_PRIVATE_KEY\[32\]/,/};/p' "$HEADER_FILE")
PRIVATE_KEY_HEX=$(echo "$PRIV_SECTION" | grep -oE '0x[0-9a-fA-F]{2}' | sed 's/0x//g' | tr '[:upper:]' '[:lower:]' | tr '\n' ' ')

# Extract public key: find "ECDSA_PUBLIC_KEY[65]" section and get 65 hex bytes
PUB_SECTION=$(sed -n '/ECDSA_PUBLIC_KEY\[65\]/,/};/p' "$HEADER_FILE")
PUBLIC_KEY_HEX=$(echo "$PUB_SECTION" | grep -oE '0x[0-9a-fA-F]{2}' | sed 's/0x//g' | tr '[:upper:]' '[:lower:]' | tr '\n' ' ')

# Verify public key starts with 04 (uncompressed point indicator)
PUB_FIRST_BYTE=$(echo "$PUBLIC_KEY_HEX" | awk '{print $1}' | tr '[:upper:]' '[:lower:]')
if [ "$PUB_FIRST_BYTE" != "04" ]; then
    echo -e "${RED}âŒ ERROR: Public key must start with 0x04 (uncompressed), got 0x$PUB_FIRST_BYTE${NC}"
    echo "   This indicates key extraction failed or keys are corrupted."
    exit 1
fi

# Validate extraction
PRIV_COUNT=$(echo "$PRIVATE_KEY_HEX" | wc -w)
PUB_COUNT=$(echo "$PUBLIC_KEY_HEX" | wc -w)

if [ "$PRIV_COUNT" -ne 32 ]; then
    echo -e "${RED}âŒ ERROR: Private key extraction failed (got $PRIV_COUNT bytes)${NC}"
    exit 1
fi

if [ "$PUB_COUNT" -ne 65 ]; then
    echo -e "${RED}âŒ ERROR: Public key extraction failed (got $PUB_COUNT bytes)${NC}"
    exit 1
fi

echo -e "${GREEN}âœ“ Private key: 32 bytes${NC}"
echo -e "${GREEN}âœ“ Public key: 65 bytes${NC}"

# Display key info (first/last 4 bytes only for security)
PRIV_FIRST=$(echo "$PRIVATE_KEY_HEX" | awk '{print $1$2$3$4}')
PRIV_LAST=$(echo "$PRIVATE_KEY_HEX" | awk '{print $(NF-3)$(NF-2)$(NF-1)$NF}')
echo ""
echo "   Private key: ${PRIV_FIRST}...${PRIV_LAST}"

PUB_FIRST=$(echo "$PUBLIC_KEY_HEX" | awk '{print $1$2$3$4}')
echo "   Public key:  ${PUB_FIRST}... (starts with 04)"

# Check device (skip in dry-run mode)
echo ""
echo "ğŸ” Checking for device in BOOTSEL mode..."
if [ $DRY_RUN -eq 1 ]; then
    if $PICOTOOL_CMD info &> /dev/null; then
        DEVICE_INFO=$($PICOTOOL_CMD info 2>/dev/null | head -5)
        echo "$DEVICE_INFO"
    else
        echo -e "${YELLOW}[DRY-RUN] No device connected - skipping device check${NC}"
    fi
else
    if ! $PICOTOOL_CMD info &> /dev/null; then
        echo -e "${RED}âŒ ERROR: No device found in BOOTSEL mode!${NC}"
        echo ""
        echo "   To enter BOOTSEL mode:"
        echo "   1. Hold BOOTSEL button"
        echo "   2. Connect USB (or press RESET while holding BOOTSEL)"
        echo "   3. Release BOOTSEL"
        exit 1
    fi
    DEVICE_INFO=$($PICOTOOL_CMD info 2>/dev/null | head -5)
    echo "$DEVICE_INFO"
fi

# Skip confirmation prompts in dry-run mode
if [ $DRY_RUN -eq 0 ]; then
    # Final warning (only for real OTP programming)
    echo ""
    echo -e "${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${RED}â•‘  âš ï¸  CRITICAL WARNING: THIS ACTION IS IRREVERSIBLE!         â•‘${NC}"
    echo -e "${RED}â•‘                                                              â•‘${NC}"
    echo -e "${RED}â•‘  OTP (One-Time Programmable) memory can ONLY be written     â•‘${NC}"
    echo -e "${RED}â•‘  ONCE. After programming:                                    â•‘${NC}"
    echo -e "${RED}â•‘                                                              â•‘${NC}"
    echo -e "${RED}â•‘  â€¢ Keys CANNOT be changed or erased                         â•‘${NC}"
    echo -e "${RED}â•‘  â€¢ This device will ALWAYS use these keys                   â•‘${NC}"
    echo -e "${RED}â•‘  â€¢ Wrong keys = device is BRICKED for authentication        â•‘${NC}"
    echo -e "${RED}â•‘                                                              â•‘${NC}"
    echo -e "${RED}â•‘  Make sure you have:                                        â•‘${NC}"
    echo -e "${RED}â•‘  âœ“ Backed up the keys securely                             â•‘${NC}"
    echo -e "${RED}â•‘  âœ“ Tested authentication with flash-based keys first       â•‘${NC}"
    echo -e "${RED}â•‘  âœ“ Verified the Flutter app works with these keys          â•‘${NC}"
    echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""

    read -p "Type 'I UNDERSTAND OTP IS PERMANENT' to continue: " confirm
    if [ "$confirm" != "I UNDERSTAND OTP IS PERMANENT" ]; then
        echo "Aborted."
        exit 0
    fi

    echo ""
    read -p "Are you ABSOLUTELY sure? (yes/no): " final_confirm
    if [ "$final_confirm" != "yes" ]; then
        echo "Aborted."
        exit 0
    fi
else
    echo ""
    echo -e "${YELLOW}[DRY-RUN] Skipping confirmation prompts${NC}"
fi

# Program OTP
echo ""
echo "ğŸ” Programming OTP..."

# Function to write OTP row (or simulate in dry-run mode)
write_otp_row() {
    local row_hex=$1
    local value=$2
    
    if [ $DRY_RUN -eq 1 ]; then
        echo "      [DRY-RUN] Would write: $PICOTOOL_CMD otp set $row_hex $value"
        return 0
    else
        if ! $PICOTOOL_CMD otp set $row_hex $value 2>&1; then
            return 1
        fi
        return 0
    fi
}

# Create individual OTP commands using picotool
# picotool otp set <row> <value> format

echo "   Writing private key (rows 0x700-0x70F)..."
PRIV_ARRAY=($PRIVATE_KEY_HEX)
for i in $(seq 0 15); do
    row=$((0x700 + i))
    byte1=${PRIV_ARRAY[$((i*2))]}
    byte2=${PRIV_ARRAY[$((i*2+1))]}
    value=$(printf "0x%s%s" "$byte1" "$byte2")
    row_hex=$(printf "0x%03x" $row)
    
    if ! write_otp_row $row_hex $value; then
        echo -e "${RED}âŒ ERROR: Failed to write OTP row $row_hex${NC}"
        exit 1
    fi
done

echo "   Writing public key (rows 0x710-0x730)..."
PUB_ARRAY=($PUBLIC_KEY_HEX)
for i in $(seq 0 32); do
    row=$((0x710 + i))
    idx1=$((i*2))
    idx2=$((i*2+1))
    
    if [ $idx1 -lt 65 ]; then
        byte1=${PUB_ARRAY[$idx1]}
    else
        byte1="00"
    fi
    
    if [ $idx2 -lt 65 ]; then
        byte2=${PUB_ARRAY[$idx2]}
    else
        byte2="00"
    fi
    
    value=$(printf "0x%s%s" "$byte1" "$byte2")
    row_hex=$(printf "0x%03x" $row)
    
    if ! write_otp_row $row_hex $value; then
        echo -e "${RED}âŒ ERROR: Failed to write OTP row $row_hex${NC}"
        exit 1
    fi
done

echo "   Writing key flag (row 0x740)..."
if ! write_otp_row 0x740 0xDC01; then
    echo -e "${RED}âŒ ERROR: Failed to write OTP flag${NC}"
    exit 1
fi

# ============================================================================
# VERIFICATION: Read back and compare
# ============================================================================
if [ $DRY_RUN -eq 1 ]; then
    echo ""
    echo -e "${YELLOW}ğŸ” DRY-RUN: Skipping verification (no data written)${NC}"
    echo ""
    echo -e "${GREEN}âœ… DRY-RUN Complete!${NC}"
    echo ""
    echo "   All commands validated. Ready for real programming."
    echo "   Remove --dry-run flag to program OTP."
    exit 0
fi

echo ""
echo "ğŸ” Verifying OTP data..."

verify_failed=0

# Verify a few private key rows
echo "   Checking private key rows..."
for i in 0 7 15; do
    row=$((0x700 + i))
    row_hex=$(printf "0x%03x" $row)
    byte1=${PRIV_ARRAY[$((i*2))]}
    byte2=${PRIV_ARRAY[$((i*2+1))]}
    expected=$(printf "%s%s" "$byte1" "$byte2" | tr '[:upper:]' '[:lower:]')
    
    # Read back using picotool (extract any hex value from output)
    readback_raw=$($PICOTOOL_CMD otp get $row_hex 2>&1)
    readback=$(echo "$readback_raw" | grep -oE '[0-9a-fA-F]{4}' | head -1 | tr '[:upper:]' '[:lower:]')
    
    if [ -z "$readback" ]; then
        echo -e "${YELLOW}   âš ï¸  Row $row_hex: Could not read back (picotool output: $readback_raw)${NC}"
        # Don't fail - just warn, as picotool output format may vary
        continue
    fi
    
    if [ "$expected" != "$readback" ]; then
        echo -e "${RED}   âŒ Row $row_hex: expected $expected, got $readback${NC}"
        verify_failed=1
    else
        echo -e "${GREEN}   âœ“ Row $row_hex: $readback${NC}"
    fi
done

# Verify flag
echo "   Checking flag row..."
flag_raw=$($PICOTOOL_CMD otp get 0x740 2>&1)
flag_readback=$(echo "$flag_raw" | grep -oE '[0-9a-fA-F]{4}' | head -1 | tr '[:upper:]' '[:lower:]')

if [ -z "$flag_readback" ]; then
    echo -e "${YELLOW}   âš ï¸  Flag row: Could not read back${NC}"
elif [ "$flag_readback" != "dc01" ]; then
    echo -e "${RED}   âŒ Flag row: expected dc01, got $flag_readback${NC}"
    verify_failed=1
else
    echo -e "${GREEN}   âœ“ Flag row: dc01${NC}"
fi

if [ $verify_failed -eq 1 ]; then
    echo ""
    echo -e "${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${RED}â•‘  âš ï¸  VERIFICATION FAILED!                                    â•‘${NC}"
    echo -e "${RED}â•‘                                                              â•‘${NC}"
    echo -e "${RED}â•‘  Some OTP data does not match what was written.             â•‘${NC}"
    echo -e "${RED}â•‘  This could indicate a hardware issue or picotool problem.  â•‘${NC}"
    echo -e "${RED}â•‘                                                              â•‘${NC}"
    echo -e "${RED}â•‘  DO NOT use this device for production!                     â•‘${NC}"
    echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    exit 1
fi

echo -e "${GREEN}âœ“ OTP verification passed${NC}"

echo ""
echo -e "${GREEN}âœ… OTP Programming Complete!${NC}"
echo ""
echo "   Keys are now permanently stored in OTP."
echo ""
echo "   Next steps:"
echo "   1. Rebuild firmware with USE_OTP_KEYS defined"
echo "   2. Flash the new firmware"
echo "   3. Test authentication with Flutter app"
echo ""
echo -e "${YELLOW}   âš ï¸  Remember to DELETE key files from your computer!${NC}"
echo "   rm -rf $KEYS_DIR"
echo ""
